# Object Oriented Programming in Python

### Overview
- A foundational programming paradigm where data is stored as attributes and code in the form of methods.
- OOP is a way to build flexible and reusable code to develop more advanced software.
- Software programs are more secure with the encapsulation approach.
- It is usually easy to maintain the code written using OOPS structure.

## 1. Fundamental concepts

Mainly 4 fundamental concepts - Class, Object, Attribute, Method

### 1.1 Class
* A class is a collection of objects, a user-defined **data structure**, which holds its own data members and member functions ***methods***
* It contains the blueprints or the prototype from which the ***objects*** are being created.
> A class **car** is supposed to be a collection of cars

### 1.2 Object
- An object is *“a thing from the real world”* of interest to the software application that we are building. 
- It is what you would want to store and process data about.
- Also called as an entity or ***instance***. An object is created using a **class**
> Your car is an object of the class car

### 1.3 Attribute
* All the information about the blueprint of a car is provided as ***attributes***
> Your car has attributes make, model, year, mileage, color, brakes, alloys
* Two types of attributes
    * **Class attributes**: These attributes are the same for all the instances of class
        > warranty is usually 3 yrs, emission standard in most cars is "Euro 6" etc
    * **Instance attributes**: These attributes are specific for an instance & are NOT necessary for initialize a class instance
        > In addition to those in __init__ method, color, alloys etc
* Attributes can be hidden using `__hiddenVariable`. To access these hidden variables, use `class._class__hiddenVariable` or `instance._class__hiddenVariable`

### 1.4 Method
* All the behavior/functionality of a class is called as a ***method***
* Methods can manipulate object's attributes and provide the functionalities defined by the class
> You can get the most recent driving info of your car, or start your car etc
* ***DO NOT CONFUSE METHOD WITH A FUNCTION!!!*** A method is defined only for a class object while a function is defined for any variable.

#### 1.4.1 Constructor or Initialize method
* Init method is called by default whenever you create an object from a ***class***
* The variables passed into this `__init__` method and are necessary for any object of class car
> A car must have a make, model, year although you can change its color, engine (mileage), brakes, alloys etc
#### 1.4.2 Self
* The term ***“self”*** refers to the instance of the class that is currently being used. It is basically a pointer to the class instance.
* By using the “self”  we can access the attributes and methods of the class instance in Python.
* `__init__` method is called when we create an instance and all the methods and attributes of this class instance are initialized

```
class car(): 
    #class variables/attributes
    no_wheels = 4
    warranty_period = 3
    emission_standard = "Euro 6"
    total_cars_initiated = 0
    total_cars = 0
    __k = 0 # hidden class attribute
    def __init__(self, make, model, year):
        #instance variables/attributes or parameters
        self.make = make
        self.model = model
        self.year = year
        car.total_cars_initiated += 1 ## total cars initiated
    def get_info(self):
        print(f"make: {self.make} \nmodel: {self.model} \nyear:{self.year}")
    def get_extended_warranty(self, no_years):
        self.warranty_period = car.warranty_period + no_years # use this to change the class attribute for this particular instance
        # car.warranty_period += no_years # use this to change the class attribute for entire class 
    @classmethod
    def set_emission_standard(cls, new_emission_standard):
        cls.emission_standard = new_emission_standard
    @classmethod
    def from_string(cls, str):
        make, model, year = str.split('-')
        return cls(make,model,year)
    @staticmethod
    def is_valid_year(year):
        return (year in range(1886,2025))
```
```
a = car("BMW", "330i", "2022")
a.get_info()
```

#### 1.4.3 Class Attributes (or Variables) [Also called as static variables]
* Get **list of all methods and attributes** of an instance using `dir(instance)` 
* Get the **namespace of a class / instance** `class.__dict__` or `instance.__dict__`
    * Class variables do not showup in the namespace of an instance, however can be accessed 
* Create **hidden variables** (both for instance or class) using `__hiddenVariable` or `self.__hiddenVariable`. Access hidden variables using `instance._class__hiddenVariable`
* We do not see the attribute `a.warranty_period` in the namespace `a.__dict__` as it is a class variable. We however see the `car.warranty_period` in `car.__dict__`
* When we access the method `get_extended_warranty(n: integer)` for an instance, it initiates the `warranty_period` as an instance attribute in the definition and then we can see it in the namespace.
* Basically class variables can be accessed for an instance `instance.classVariable` however we don't see those in the namespace unless initiated as an instance variable in one of the methods of a class.
* The `total_cars_initiated` is a class variable that gets updated each time the class `car` is initiated. 

```
print(f"List of all methods & attributes \n{dir(a)}\n")
print(f"Namespace of instance {a.__dict__}")
print(f"Class namespace: {car.__dict__}")

print(f"Hidden variable __k={a._car__k}")

a.get_extended_warranty(3)
print(f"Instance namespace: {a.__dict__}")

b = car("Tesla","Model-S","2024")
print(f"Total cars = {car.total_cars_initiated}")
```

#### 1.4.4 Types of Methods - Regular, Class & Static
**Regular Methods**
* They take the instance (`self`) as the first argument. This is to change the attributes/methods of an instance. 

**Class Methods**
* They take class (`cls`) as the first argument. Created using a decorator `@classmethod`
> In the above class, `car.emission_standard = "Euro 7"` is the same as `car.set_emission_standard("Euro 7")`.
> However, `a.emission_standard = "Euro 7"` is NOT the same as `a.set_emission_standard("Euro 7")` because the class method `set_emission_standard` changes emission_standard for the entire class.
* Using class methods for an instance DOES NOT make sense, however the code technically works ableit for the entire class.
* Class methods are also used as **alternative constructors**
    * Assuming we are receiving data for each car instance in a string format `"make-model-year"`, then we can initialize a instance using the method `c = car.from_string("GMC-Hummer-2024")`

**Static Methods**
* Do not take either an instance `self` or a class `cls` as the argument. Created using a decorator `@staticmethod`
* However, these methods still have some connection with the class which is why they are not stand alone Functions!
> Assuming valid year for a car is 1886 (first manufactured car was in 1886), we can check the year validity using the method `a.is_valid_year(a.year)`